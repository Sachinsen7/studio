/**
 * Core Philosophy: This ruleset enforces a hybrid security model tailored for a project management application.
 * It combines a strict user-ownership model for personal data with a collaborative, role-based model for shared resources.
 * The primary goal is to ensure that users can only access data they own or are explicitly granted access to, while maintaining flexibility for application development.
 *
 * Data Structure: The data is organized into several top-level collections: 'employees', 'projects', 'tasks', and 'roles'.
 * - Employee-specific data, such as attendance and leave requests, is nested under '/employees/{employeeId}/', linking it directly to a user's authentication ID.
 * - Shared data, such as '/projects/{projectId}', exists at the top level and manages its own access control list.
 * - Cross-cutting concerns like '/tasks/{taskId}' are also top-level but contain references (e.g., 'projectId', 'employeeId') to link back to the entities they relate to for authorization checks.
 *
 * Key Security Decisions:
 * - Employee ID as Auth UID: The rules assume that the document ID in the '/employees' collection (`employeeId`) is identical to the Firebase Authentication User ID (`request.auth.uid`). This creates a strong, unambiguous link between a user's identity and their data.
 * - Denormalization for Project Access: To secure projects and their related data (like tasks) efficiently, we assume that each '/projects/{projectId}' document contains a 'members' map. This map stores user UIDs as keys and their roles (e.g., 'owner', 'editor', 'viewer') as values. This avoids slow, costly, and sometimes impossible lookups in other collections during rule evaluation.
 * - No Public Listing: By default, top-level collections that contain sensitive or collaborative data (e.g., 'projects', 'tasks', 'employees') cannot be listed in their entirety. Clients must construct specific queries (e.g., 'list all projects where I am a member') which are then secured at the document level.
 * - Read-Only Definitions: The '/roles' collection is treated as definitional data. It is publicly readable by any authenticated user but is locked down against writes to prevent unauthorized changes to the role system.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Verifies that the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Verifies that the request is coming from the owner of the document.
     * Assumes the document ID ({userId}) is the same as the user's auth UID.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Verifies that a document exists before an update or delete operation.
     */
    function isExistingDocument() {
      return resource != null;
    }

    /**
     * Verifies ownership for an existing document, used for update/delete.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDocument();
    }

    /**
     * Retrieves the data of a project document.
     * This is a key function for securing related collections like 'tasks'.
     */
    function getProjectData(projectId) {
      return get(/databases/$(database)/documents/projects/$(projectId)).data;
    }

    /**
     * Checks if the currently authenticated user is a member of a given project.
     * Assumes the project document has a 'members' map field.
     * e.g., { members: { 'user_abc': 'editor', 'user_xyz': 'viewer' } }
     */
    function isProjectMember(projectId) {
      return isSignedIn() && request.auth.uid in getProjectData(projectId).members;
    }

    /**
     * Checks if the user has a privileged role (e.g., 'owner' or 'admin') in a project.
     * This is used to control who can modify project details or manage members.
     */
    function canManageProject(projectId) {
      return isSignedIn() && getProjectData(projectId).members[request.auth.uid] in ['owner', 'admin'];
    }

    /**
     * Validates that the creator of a project is properly listed as an owner
     * in the 'members' map of the new document.
     */
    function isProjectCreatorAndOwner(data) {
      return isSignedIn() && request.auth.uid in data.members && data.members[request.auth.uid] == 'owner';
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Secures employee profiles. Only the employee themselves can read or write their own data.
     * @path /employees/{employeeId}
     * @allow (get) A signed-in user (auth.uid='user123') reads their own profile at /employees/user123.
     * @deny (get) A signed-in user (auth.uid='user456') tries to read another user's profile at /employees/user123.
     * @principle Restricts access to a user's own data tree using path-based ownership.
     */
    match /employees/{employeeId} {
      allow get: if isOwner(employeeId);
      allow list: if false; // Disallow listing all employees for security.
      allow create: if isOwner(employeeId) && request.resource.data.id == employeeId;
      allow update: if isExistingOwner(employeeId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(employeeId);

      /**
       * @description Secures an employee's attendance records. Access is inherited from the parent employee document.
       * @path /employees/{employeeId}/attendance/{attendanceId}
       * @allow (create) A signed-in user (auth.uid='user123') creates an attendance record for themselves.
       * @deny (list) A manager tries to list the attendance for user 'user123'.
       * @principle Enforces strict ownership for sensitive, nested user data.
       */
      match /attendance/{attendanceId} {
        allow get, list: if isOwner(employeeId);
        allow create: if isOwner(employeeId) && request.resource.data.employeeId == employeeId;
        allow update: if isExistingOwner(employeeId) && request.resource.data.employeeId == resource.data.employeeId;
        allow delete: if isExistingOwner(employeeId);
      }

      /**
       * @description Secures an employee's leave requests. Access is inherited from the parent employee document.
       * @path /employees/{employeeId}/leaveRequests/{leaveRequestId}
       * @allow (get) A signed-in user (auth.uid='user123') reads their own leave request.
       * @deny (update) Another user tries to approve a leave request for 'user123'.
       * @principle Enforces strict ownership for sensitive, nested user data.
       */
      match /leaveRequests/{leaveRequestId} {
        allow get, list: if isOwner(employeeId);
        allow create: if isOwner(employeeId) && request.resource.data.employeeId == employeeId;
        allow update: if isExistingOwner(employeeId) && request.resource.data.employeeId == resource.data.employeeId;
        allow delete: if isExistingOwner(employeeId);
      }
    }

    /**
     * @description Secures project documents. Access is controlled by a 'members' map within each project.
     * @path /projects/{projectId}
     * @allow (get) A user in the project's 'members' map reads the project document.
     * @deny (update) A user with a 'viewer' role tries to change the project description.
     * @principle Implements a collaborative access model using a denormalized list of members on the document itself.
     */
    match /projects/{projectId} {
      allow get: if isProjectMember(projectId);
      allow list: if false; // Disallow listing all projects; client must query by membership.
      allow create: if isProjectCreatorAndOwner(request.resource.data) && request.resource.data.id == projectId;
      allow update: if isExistingDocument() && canManageProject(projectId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingDocument() && canManageProject(projectId);

      /**
       * @description Secures the list of employees associated with a project.
       * @path /projects/{projectId}/employees/{employeeId}
       * @allow (list) A project member lists the employees on that project.
       * @deny (create) A user with a 'viewer' role tries to add an employee to the project.
       * @principle Secures a subcollection based on the authorization state of its parent document.
       */
      match /employees/{employeeId} {
        allow get, list: if isProjectMember(projectId);
        allow create: if canManageProject(projectId) && request.resource.data.projectId == projectId;
        allow update: if isExistingDocument() && canManageProject(projectId) && request.resource.data.projectId == resource.data.projectId;
        allow delete: if isExistingDocument() && canManageProject(projectId);
      }
    }

    /**
     * @description Secures task documents. Access is derived from membership in the associated project.
     * @path /tasks/{taskId}
     * @allow (get) A user who is a member of the task's parent project reads the task.
     * @deny (update) A user who is not a member of the project tries to change the task status.
     * @principle Validates relational integrity by checking a parent resource ('project') for authorization.
     */
    match /tasks/{taskId} {
      allow get: if isProjectMember(resource.data.projectId);
      allow list: if false; // Disallow listing all tasks; client must query by project or assignee.
      allow create: if isProjectMember(request.resource.data.projectId);
      allow update: if isExistingDocument() && isProjectMember(resource.data.projectId);
      allow delete: if isExistingDocument() && isProjectMember(resource.data.projectId);
    }

    /**
     * @description Defines company roles. This data is public to all authenticated users but cannot be modified.
     * @path /roles/{roleId}
     * @allow (list) Any authenticated user reads the list of available roles.
     * @deny (create) Any user attempts to create a new role.
     * @principle Treats definitional data as read-only to maintain system integrity.
     */
    match /roles/{roleId} {
      allow get, list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}